package main

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i shoppingcart.service -o ./service_mock_test.go

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ServiceMock implements service
type ServiceMock struct {
	t minimock.Tester

	funcCartCreate          func(ctx context.Context, userID int64, items []*LineItem) (cp1 *Cart, err error)
	inspectFuncCartCreate   func(ctx context.Context, userID int64, items []*LineItem)
	afterCartCreateCounter  uint64
	beforeCartCreateCounter uint64
	CartCreateMock          mServiceMockCartCreate

	funcCartEmpty          func(ctx context.Context, cartID int64) (err error)
	inspectFuncCartEmpty   func(ctx context.Context, cartID int64)
	afterCartEmptyCounter  uint64
	beforeCartEmptyCounter uint64
	CartEmptyMock          mServiceMockCartEmpty

	funcCartShow          func(ctx context.Context, cartID int64) (cp1 *Cart, err error)
	inspectFuncCartShow   func(ctx context.Context, cartID int64)
	afterCartShowCounter  uint64
	beforeCartShowCounter uint64
	CartShowMock          mServiceMockCartShow

	funcLineItemAdd          func(ctx context.Context, cartID int64, items []*LineItem) (lpa1 []*LineItem, err error)
	inspectFuncLineItemAdd   func(ctx context.Context, cartID int64, items []*LineItem)
	afterLineItemAddCounter  uint64
	beforeLineItemAddCounter uint64
	LineItemAddMock          mServiceMockLineItemAdd

	funcLineItemRemove          func(ctx context.Context, cartID int64, itemID int64) (err error)
	inspectFuncLineItemRemove   func(ctx context.Context, cartID int64, itemID int64)
	afterLineItemRemoveCounter  uint64
	beforeLineItemRemoveCounter uint64
	LineItemRemoveMock          mServiceMockLineItemRemove
}

// NewServiceMock returns a mock for service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CartCreateMock = mServiceMockCartCreate{mock: m}
	m.CartCreateMock.callArgs = []*ServiceMockCartCreateParams{}

	m.CartEmptyMock = mServiceMockCartEmpty{mock: m}
	m.CartEmptyMock.callArgs = []*ServiceMockCartEmptyParams{}

	m.CartShowMock = mServiceMockCartShow{mock: m}
	m.CartShowMock.callArgs = []*ServiceMockCartShowParams{}

	m.LineItemAddMock = mServiceMockLineItemAdd{mock: m}
	m.LineItemAddMock.callArgs = []*ServiceMockLineItemAddParams{}

	m.LineItemRemoveMock = mServiceMockLineItemRemove{mock: m}
	m.LineItemRemoveMock.callArgs = []*ServiceMockLineItemRemoveParams{}

	return m
}

type mServiceMockCartCreate struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockCartCreateExpectation
	expectations       []*ServiceMockCartCreateExpectation

	callArgs []*ServiceMockCartCreateParams
	mutex    sync.RWMutex
}

// ServiceMockCartCreateExpectation specifies expectation struct of the service.CartCreate
type ServiceMockCartCreateExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockCartCreateParams
	results *ServiceMockCartCreateResults
	Counter uint64
}

// ServiceMockCartCreateParams contains parameters of the service.CartCreate
type ServiceMockCartCreateParams struct {
	ctx    context.Context
	userID int64
	items  []*LineItem
}

// ServiceMockCartCreateResults contains results of the service.CartCreate
type ServiceMockCartCreateResults struct {
	cp1 *Cart
	err error
}

// Expect sets up expected params for service.CartCreate
func (mmCartCreate *mServiceMockCartCreate) Expect(ctx context.Context, userID int64, items []*LineItem) *mServiceMockCartCreate {
	if mmCartCreate.mock.funcCartCreate != nil {
		mmCartCreate.mock.t.Fatalf("ServiceMock.CartCreate mock is already set by Set")
	}

	if mmCartCreate.defaultExpectation == nil {
		mmCartCreate.defaultExpectation = &ServiceMockCartCreateExpectation{}
	}

	mmCartCreate.defaultExpectation.params = &ServiceMockCartCreateParams{ctx, userID, items}
	for _, e := range mmCartCreate.expectations {
		if minimock.Equal(e.params, mmCartCreate.defaultExpectation.params) {
			mmCartCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCartCreate.defaultExpectation.params)
		}
	}

	return mmCartCreate
}

// Inspect accepts an inspector function that has same arguments as the service.CartCreate
func (mmCartCreate *mServiceMockCartCreate) Inspect(f func(ctx context.Context, userID int64, items []*LineItem)) *mServiceMockCartCreate {
	if mmCartCreate.mock.inspectFuncCartCreate != nil {
		mmCartCreate.mock.t.Fatalf("Inspect function is already set for ServiceMock.CartCreate")
	}

	mmCartCreate.mock.inspectFuncCartCreate = f

	return mmCartCreate
}

// Return sets up results that will be returned by service.CartCreate
func (mmCartCreate *mServiceMockCartCreate) Return(cp1 *Cart, err error) *ServiceMock {
	if mmCartCreate.mock.funcCartCreate != nil {
		mmCartCreate.mock.t.Fatalf("ServiceMock.CartCreate mock is already set by Set")
	}

	if mmCartCreate.defaultExpectation == nil {
		mmCartCreate.defaultExpectation = &ServiceMockCartCreateExpectation{mock: mmCartCreate.mock}
	}
	mmCartCreate.defaultExpectation.results = &ServiceMockCartCreateResults{cp1, err}
	return mmCartCreate.mock
}

//Set uses given function f to mock the service.CartCreate method
func (mmCartCreate *mServiceMockCartCreate) Set(f func(ctx context.Context, userID int64, items []*LineItem) (cp1 *Cart, err error)) *ServiceMock {
	if mmCartCreate.defaultExpectation != nil {
		mmCartCreate.mock.t.Fatalf("Default expectation is already set for the service.CartCreate method")
	}

	if len(mmCartCreate.expectations) > 0 {
		mmCartCreate.mock.t.Fatalf("Some expectations are already set for the service.CartCreate method")
	}

	mmCartCreate.mock.funcCartCreate = f
	return mmCartCreate.mock
}

// When sets expectation for the service.CartCreate which will trigger the result defined by the following
// Then helper
func (mmCartCreate *mServiceMockCartCreate) When(ctx context.Context, userID int64, items []*LineItem) *ServiceMockCartCreateExpectation {
	if mmCartCreate.mock.funcCartCreate != nil {
		mmCartCreate.mock.t.Fatalf("ServiceMock.CartCreate mock is already set by Set")
	}

	expectation := &ServiceMockCartCreateExpectation{
		mock:   mmCartCreate.mock,
		params: &ServiceMockCartCreateParams{ctx, userID, items},
	}
	mmCartCreate.expectations = append(mmCartCreate.expectations, expectation)
	return expectation
}

// Then sets up service.CartCreate return parameters for the expectation previously defined by the When method
func (e *ServiceMockCartCreateExpectation) Then(cp1 *Cart, err error) *ServiceMock {
	e.results = &ServiceMockCartCreateResults{cp1, err}
	return e.mock
}

// CartCreate implements service
func (mmCartCreate *ServiceMock) CartCreate(ctx context.Context, userID int64, items []*LineItem) (cp1 *Cart, err error) {
	mm_atomic.AddUint64(&mmCartCreate.beforeCartCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCartCreate.afterCartCreateCounter, 1)

	if mmCartCreate.inspectFuncCartCreate != nil {
		mmCartCreate.inspectFuncCartCreate(ctx, userID, items)
	}

	mm_params := &ServiceMockCartCreateParams{ctx, userID, items}

	// Record call args
	mmCartCreate.CartCreateMock.mutex.Lock()
	mmCartCreate.CartCreateMock.callArgs = append(mmCartCreate.CartCreateMock.callArgs, mm_params)
	mmCartCreate.CartCreateMock.mutex.Unlock()

	for _, e := range mmCartCreate.CartCreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCartCreate.CartCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCartCreate.CartCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCartCreate.CartCreateMock.defaultExpectation.params
		mm_got := ServiceMockCartCreateParams{ctx, userID, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCartCreate.t.Errorf("ServiceMock.CartCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCartCreate.CartCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCartCreate.t.Fatal("No results are set for the ServiceMock.CartCreate")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCartCreate.funcCartCreate != nil {
		return mmCartCreate.funcCartCreate(ctx, userID, items)
	}
	mmCartCreate.t.Fatalf("Unexpected call to ServiceMock.CartCreate. %v %v %v", ctx, userID, items)
	return
}

// CartCreateAfterCounter returns a count of finished ServiceMock.CartCreate invocations
func (mmCartCreate *ServiceMock) CartCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartCreate.afterCartCreateCounter)
}

// CartCreateBeforeCounter returns a count of ServiceMock.CartCreate invocations
func (mmCartCreate *ServiceMock) CartCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartCreate.beforeCartCreateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CartCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCartCreate *mServiceMockCartCreate) Calls() []*ServiceMockCartCreateParams {
	mmCartCreate.mutex.RLock()

	argCopy := make([]*ServiceMockCartCreateParams, len(mmCartCreate.callArgs))
	copy(argCopy, mmCartCreate.callArgs)

	mmCartCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCartCreateDone returns true if the count of the CartCreate invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCartCreateDone() bool {
	for _, e := range m.CartCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartCreate != nil && mm_atomic.LoadUint64(&m.afterCartCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCartCreateInspect logs each unmet expectation
func (m *ServiceMock) MinimockCartCreateInspect() {
	for _, e := range m.CartCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CartCreate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartCreateCounter) < 1 {
		if m.CartCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.CartCreate")
		} else {
			m.t.Errorf("Expected call to ServiceMock.CartCreate with params: %#v", *m.CartCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartCreate != nil && mm_atomic.LoadUint64(&m.afterCartCreateCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.CartCreate")
	}
}

type mServiceMockCartEmpty struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockCartEmptyExpectation
	expectations       []*ServiceMockCartEmptyExpectation

	callArgs []*ServiceMockCartEmptyParams
	mutex    sync.RWMutex
}

// ServiceMockCartEmptyExpectation specifies expectation struct of the service.CartEmpty
type ServiceMockCartEmptyExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockCartEmptyParams
	results *ServiceMockCartEmptyResults
	Counter uint64
}

// ServiceMockCartEmptyParams contains parameters of the service.CartEmpty
type ServiceMockCartEmptyParams struct {
	ctx    context.Context
	cartID int64
}

// ServiceMockCartEmptyResults contains results of the service.CartEmpty
type ServiceMockCartEmptyResults struct {
	err error
}

// Expect sets up expected params for service.CartEmpty
func (mmCartEmpty *mServiceMockCartEmpty) Expect(ctx context.Context, cartID int64) *mServiceMockCartEmpty {
	if mmCartEmpty.mock.funcCartEmpty != nil {
		mmCartEmpty.mock.t.Fatalf("ServiceMock.CartEmpty mock is already set by Set")
	}

	if mmCartEmpty.defaultExpectation == nil {
		mmCartEmpty.defaultExpectation = &ServiceMockCartEmptyExpectation{}
	}

	mmCartEmpty.defaultExpectation.params = &ServiceMockCartEmptyParams{ctx, cartID}
	for _, e := range mmCartEmpty.expectations {
		if minimock.Equal(e.params, mmCartEmpty.defaultExpectation.params) {
			mmCartEmpty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCartEmpty.defaultExpectation.params)
		}
	}

	return mmCartEmpty
}

// Inspect accepts an inspector function that has same arguments as the service.CartEmpty
func (mmCartEmpty *mServiceMockCartEmpty) Inspect(f func(ctx context.Context, cartID int64)) *mServiceMockCartEmpty {
	if mmCartEmpty.mock.inspectFuncCartEmpty != nil {
		mmCartEmpty.mock.t.Fatalf("Inspect function is already set for ServiceMock.CartEmpty")
	}

	mmCartEmpty.mock.inspectFuncCartEmpty = f

	return mmCartEmpty
}

// Return sets up results that will be returned by service.CartEmpty
func (mmCartEmpty *mServiceMockCartEmpty) Return(err error) *ServiceMock {
	if mmCartEmpty.mock.funcCartEmpty != nil {
		mmCartEmpty.mock.t.Fatalf("ServiceMock.CartEmpty mock is already set by Set")
	}

	if mmCartEmpty.defaultExpectation == nil {
		mmCartEmpty.defaultExpectation = &ServiceMockCartEmptyExpectation{mock: mmCartEmpty.mock}
	}
	mmCartEmpty.defaultExpectation.results = &ServiceMockCartEmptyResults{err}
	return mmCartEmpty.mock
}

//Set uses given function f to mock the service.CartEmpty method
func (mmCartEmpty *mServiceMockCartEmpty) Set(f func(ctx context.Context, cartID int64) (err error)) *ServiceMock {
	if mmCartEmpty.defaultExpectation != nil {
		mmCartEmpty.mock.t.Fatalf("Default expectation is already set for the service.CartEmpty method")
	}

	if len(mmCartEmpty.expectations) > 0 {
		mmCartEmpty.mock.t.Fatalf("Some expectations are already set for the service.CartEmpty method")
	}

	mmCartEmpty.mock.funcCartEmpty = f
	return mmCartEmpty.mock
}

// When sets expectation for the service.CartEmpty which will trigger the result defined by the following
// Then helper
func (mmCartEmpty *mServiceMockCartEmpty) When(ctx context.Context, cartID int64) *ServiceMockCartEmptyExpectation {
	if mmCartEmpty.mock.funcCartEmpty != nil {
		mmCartEmpty.mock.t.Fatalf("ServiceMock.CartEmpty mock is already set by Set")
	}

	expectation := &ServiceMockCartEmptyExpectation{
		mock:   mmCartEmpty.mock,
		params: &ServiceMockCartEmptyParams{ctx, cartID},
	}
	mmCartEmpty.expectations = append(mmCartEmpty.expectations, expectation)
	return expectation
}

// Then sets up service.CartEmpty return parameters for the expectation previously defined by the When method
func (e *ServiceMockCartEmptyExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCartEmptyResults{err}
	return e.mock
}

// CartEmpty implements service
func (mmCartEmpty *ServiceMock) CartEmpty(ctx context.Context, cartID int64) (err error) {
	mm_atomic.AddUint64(&mmCartEmpty.beforeCartEmptyCounter, 1)
	defer mm_atomic.AddUint64(&mmCartEmpty.afterCartEmptyCounter, 1)

	if mmCartEmpty.inspectFuncCartEmpty != nil {
		mmCartEmpty.inspectFuncCartEmpty(ctx, cartID)
	}

	mm_params := &ServiceMockCartEmptyParams{ctx, cartID}

	// Record call args
	mmCartEmpty.CartEmptyMock.mutex.Lock()
	mmCartEmpty.CartEmptyMock.callArgs = append(mmCartEmpty.CartEmptyMock.callArgs, mm_params)
	mmCartEmpty.CartEmptyMock.mutex.Unlock()

	for _, e := range mmCartEmpty.CartEmptyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCartEmpty.CartEmptyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCartEmpty.CartEmptyMock.defaultExpectation.Counter, 1)
		mm_want := mmCartEmpty.CartEmptyMock.defaultExpectation.params
		mm_got := ServiceMockCartEmptyParams{ctx, cartID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCartEmpty.t.Errorf("ServiceMock.CartEmpty got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCartEmpty.CartEmptyMock.defaultExpectation.results
		if mm_results == nil {
			mmCartEmpty.t.Fatal("No results are set for the ServiceMock.CartEmpty")
		}
		return (*mm_results).err
	}
	if mmCartEmpty.funcCartEmpty != nil {
		return mmCartEmpty.funcCartEmpty(ctx, cartID)
	}
	mmCartEmpty.t.Fatalf("Unexpected call to ServiceMock.CartEmpty. %v %v", ctx, cartID)
	return
}

// CartEmptyAfterCounter returns a count of finished ServiceMock.CartEmpty invocations
func (mmCartEmpty *ServiceMock) CartEmptyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartEmpty.afterCartEmptyCounter)
}

// CartEmptyBeforeCounter returns a count of ServiceMock.CartEmpty invocations
func (mmCartEmpty *ServiceMock) CartEmptyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartEmpty.beforeCartEmptyCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CartEmpty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCartEmpty *mServiceMockCartEmpty) Calls() []*ServiceMockCartEmptyParams {
	mmCartEmpty.mutex.RLock()

	argCopy := make([]*ServiceMockCartEmptyParams, len(mmCartEmpty.callArgs))
	copy(argCopy, mmCartEmpty.callArgs)

	mmCartEmpty.mutex.RUnlock()

	return argCopy
}

// MinimockCartEmptyDone returns true if the count of the CartEmpty invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCartEmptyDone() bool {
	for _, e := range m.CartEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartEmptyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartEmpty != nil && mm_atomic.LoadUint64(&m.afterCartEmptyCounter) < 1 {
		return false
	}
	return true
}

// MinimockCartEmptyInspect logs each unmet expectation
func (m *ServiceMock) MinimockCartEmptyInspect() {
	for _, e := range m.CartEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CartEmpty with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartEmptyCounter) < 1 {
		if m.CartEmptyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.CartEmpty")
		} else {
			m.t.Errorf("Expected call to ServiceMock.CartEmpty with params: %#v", *m.CartEmptyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartEmpty != nil && mm_atomic.LoadUint64(&m.afterCartEmptyCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.CartEmpty")
	}
}

type mServiceMockCartShow struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockCartShowExpectation
	expectations       []*ServiceMockCartShowExpectation

	callArgs []*ServiceMockCartShowParams
	mutex    sync.RWMutex
}

// ServiceMockCartShowExpectation specifies expectation struct of the service.CartShow
type ServiceMockCartShowExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockCartShowParams
	results *ServiceMockCartShowResults
	Counter uint64
}

// ServiceMockCartShowParams contains parameters of the service.CartShow
type ServiceMockCartShowParams struct {
	ctx    context.Context
	cartID int64
}

// ServiceMockCartShowResults contains results of the service.CartShow
type ServiceMockCartShowResults struct {
	cp1 *Cart
	err error
}

// Expect sets up expected params for service.CartShow
func (mmCartShow *mServiceMockCartShow) Expect(ctx context.Context, cartID int64) *mServiceMockCartShow {
	if mmCartShow.mock.funcCartShow != nil {
		mmCartShow.mock.t.Fatalf("ServiceMock.CartShow mock is already set by Set")
	}

	if mmCartShow.defaultExpectation == nil {
		mmCartShow.defaultExpectation = &ServiceMockCartShowExpectation{}
	}

	mmCartShow.defaultExpectation.params = &ServiceMockCartShowParams{ctx, cartID}
	for _, e := range mmCartShow.expectations {
		if minimock.Equal(e.params, mmCartShow.defaultExpectation.params) {
			mmCartShow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCartShow.defaultExpectation.params)
		}
	}

	return mmCartShow
}

// Inspect accepts an inspector function that has same arguments as the service.CartShow
func (mmCartShow *mServiceMockCartShow) Inspect(f func(ctx context.Context, cartID int64)) *mServiceMockCartShow {
	if mmCartShow.mock.inspectFuncCartShow != nil {
		mmCartShow.mock.t.Fatalf("Inspect function is already set for ServiceMock.CartShow")
	}

	mmCartShow.mock.inspectFuncCartShow = f

	return mmCartShow
}

// Return sets up results that will be returned by service.CartShow
func (mmCartShow *mServiceMockCartShow) Return(cp1 *Cart, err error) *ServiceMock {
	if mmCartShow.mock.funcCartShow != nil {
		mmCartShow.mock.t.Fatalf("ServiceMock.CartShow mock is already set by Set")
	}

	if mmCartShow.defaultExpectation == nil {
		mmCartShow.defaultExpectation = &ServiceMockCartShowExpectation{mock: mmCartShow.mock}
	}
	mmCartShow.defaultExpectation.results = &ServiceMockCartShowResults{cp1, err}
	return mmCartShow.mock
}

//Set uses given function f to mock the service.CartShow method
func (mmCartShow *mServiceMockCartShow) Set(f func(ctx context.Context, cartID int64) (cp1 *Cart, err error)) *ServiceMock {
	if mmCartShow.defaultExpectation != nil {
		mmCartShow.mock.t.Fatalf("Default expectation is already set for the service.CartShow method")
	}

	if len(mmCartShow.expectations) > 0 {
		mmCartShow.mock.t.Fatalf("Some expectations are already set for the service.CartShow method")
	}

	mmCartShow.mock.funcCartShow = f
	return mmCartShow.mock
}

// When sets expectation for the service.CartShow which will trigger the result defined by the following
// Then helper
func (mmCartShow *mServiceMockCartShow) When(ctx context.Context, cartID int64) *ServiceMockCartShowExpectation {
	if mmCartShow.mock.funcCartShow != nil {
		mmCartShow.mock.t.Fatalf("ServiceMock.CartShow mock is already set by Set")
	}

	expectation := &ServiceMockCartShowExpectation{
		mock:   mmCartShow.mock,
		params: &ServiceMockCartShowParams{ctx, cartID},
	}
	mmCartShow.expectations = append(mmCartShow.expectations, expectation)
	return expectation
}

// Then sets up service.CartShow return parameters for the expectation previously defined by the When method
func (e *ServiceMockCartShowExpectation) Then(cp1 *Cart, err error) *ServiceMock {
	e.results = &ServiceMockCartShowResults{cp1, err}
	return e.mock
}

// CartShow implements service
func (mmCartShow *ServiceMock) CartShow(ctx context.Context, cartID int64) (cp1 *Cart, err error) {
	mm_atomic.AddUint64(&mmCartShow.beforeCartShowCounter, 1)
	defer mm_atomic.AddUint64(&mmCartShow.afterCartShowCounter, 1)

	if mmCartShow.inspectFuncCartShow != nil {
		mmCartShow.inspectFuncCartShow(ctx, cartID)
	}

	mm_params := &ServiceMockCartShowParams{ctx, cartID}

	// Record call args
	mmCartShow.CartShowMock.mutex.Lock()
	mmCartShow.CartShowMock.callArgs = append(mmCartShow.CartShowMock.callArgs, mm_params)
	mmCartShow.CartShowMock.mutex.Unlock()

	for _, e := range mmCartShow.CartShowMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCartShow.CartShowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCartShow.CartShowMock.defaultExpectation.Counter, 1)
		mm_want := mmCartShow.CartShowMock.defaultExpectation.params
		mm_got := ServiceMockCartShowParams{ctx, cartID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCartShow.t.Errorf("ServiceMock.CartShow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCartShow.CartShowMock.defaultExpectation.results
		if mm_results == nil {
			mmCartShow.t.Fatal("No results are set for the ServiceMock.CartShow")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCartShow.funcCartShow != nil {
		return mmCartShow.funcCartShow(ctx, cartID)
	}
	mmCartShow.t.Fatalf("Unexpected call to ServiceMock.CartShow. %v %v", ctx, cartID)
	return
}

// CartShowAfterCounter returns a count of finished ServiceMock.CartShow invocations
func (mmCartShow *ServiceMock) CartShowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartShow.afterCartShowCounter)
}

// CartShowBeforeCounter returns a count of ServiceMock.CartShow invocations
func (mmCartShow *ServiceMock) CartShowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartShow.beforeCartShowCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CartShow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCartShow *mServiceMockCartShow) Calls() []*ServiceMockCartShowParams {
	mmCartShow.mutex.RLock()

	argCopy := make([]*ServiceMockCartShowParams, len(mmCartShow.callArgs))
	copy(argCopy, mmCartShow.callArgs)

	mmCartShow.mutex.RUnlock()

	return argCopy
}

// MinimockCartShowDone returns true if the count of the CartShow invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCartShowDone() bool {
	for _, e := range m.CartShowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartShowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartShowCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartShow != nil && mm_atomic.LoadUint64(&m.afterCartShowCounter) < 1 {
		return false
	}
	return true
}

// MinimockCartShowInspect logs each unmet expectation
func (m *ServiceMock) MinimockCartShowInspect() {
	for _, e := range m.CartShowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CartShow with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartShowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartShowCounter) < 1 {
		if m.CartShowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.CartShow")
		} else {
			m.t.Errorf("Expected call to ServiceMock.CartShow with params: %#v", *m.CartShowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartShow != nil && mm_atomic.LoadUint64(&m.afterCartShowCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.CartShow")
	}
}

type mServiceMockLineItemAdd struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockLineItemAddExpectation
	expectations       []*ServiceMockLineItemAddExpectation

	callArgs []*ServiceMockLineItemAddParams
	mutex    sync.RWMutex
}

// ServiceMockLineItemAddExpectation specifies expectation struct of the service.LineItemAdd
type ServiceMockLineItemAddExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockLineItemAddParams
	results *ServiceMockLineItemAddResults
	Counter uint64
}

// ServiceMockLineItemAddParams contains parameters of the service.LineItemAdd
type ServiceMockLineItemAddParams struct {
	ctx    context.Context
	cartID int64
	items  []*LineItem
}

// ServiceMockLineItemAddResults contains results of the service.LineItemAdd
type ServiceMockLineItemAddResults struct {
	lpa1 []*LineItem
	err  error
}

// Expect sets up expected params for service.LineItemAdd
func (mmLineItemAdd *mServiceMockLineItemAdd) Expect(ctx context.Context, cartID int64, items []*LineItem) *mServiceMockLineItemAdd {
	if mmLineItemAdd.mock.funcLineItemAdd != nil {
		mmLineItemAdd.mock.t.Fatalf("ServiceMock.LineItemAdd mock is already set by Set")
	}

	if mmLineItemAdd.defaultExpectation == nil {
		mmLineItemAdd.defaultExpectation = &ServiceMockLineItemAddExpectation{}
	}

	mmLineItemAdd.defaultExpectation.params = &ServiceMockLineItemAddParams{ctx, cartID, items}
	for _, e := range mmLineItemAdd.expectations {
		if minimock.Equal(e.params, mmLineItemAdd.defaultExpectation.params) {
			mmLineItemAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLineItemAdd.defaultExpectation.params)
		}
	}

	return mmLineItemAdd
}

// Inspect accepts an inspector function that has same arguments as the service.LineItemAdd
func (mmLineItemAdd *mServiceMockLineItemAdd) Inspect(f func(ctx context.Context, cartID int64, items []*LineItem)) *mServiceMockLineItemAdd {
	if mmLineItemAdd.mock.inspectFuncLineItemAdd != nil {
		mmLineItemAdd.mock.t.Fatalf("Inspect function is already set for ServiceMock.LineItemAdd")
	}

	mmLineItemAdd.mock.inspectFuncLineItemAdd = f

	return mmLineItemAdd
}

// Return sets up results that will be returned by service.LineItemAdd
func (mmLineItemAdd *mServiceMockLineItemAdd) Return(lpa1 []*LineItem, err error) *ServiceMock {
	if mmLineItemAdd.mock.funcLineItemAdd != nil {
		mmLineItemAdd.mock.t.Fatalf("ServiceMock.LineItemAdd mock is already set by Set")
	}

	if mmLineItemAdd.defaultExpectation == nil {
		mmLineItemAdd.defaultExpectation = &ServiceMockLineItemAddExpectation{mock: mmLineItemAdd.mock}
	}
	mmLineItemAdd.defaultExpectation.results = &ServiceMockLineItemAddResults{lpa1, err}
	return mmLineItemAdd.mock
}

//Set uses given function f to mock the service.LineItemAdd method
func (mmLineItemAdd *mServiceMockLineItemAdd) Set(f func(ctx context.Context, cartID int64, items []*LineItem) (lpa1 []*LineItem, err error)) *ServiceMock {
	if mmLineItemAdd.defaultExpectation != nil {
		mmLineItemAdd.mock.t.Fatalf("Default expectation is already set for the service.LineItemAdd method")
	}

	if len(mmLineItemAdd.expectations) > 0 {
		mmLineItemAdd.mock.t.Fatalf("Some expectations are already set for the service.LineItemAdd method")
	}

	mmLineItemAdd.mock.funcLineItemAdd = f
	return mmLineItemAdd.mock
}

// When sets expectation for the service.LineItemAdd which will trigger the result defined by the following
// Then helper
func (mmLineItemAdd *mServiceMockLineItemAdd) When(ctx context.Context, cartID int64, items []*LineItem) *ServiceMockLineItemAddExpectation {
	if mmLineItemAdd.mock.funcLineItemAdd != nil {
		mmLineItemAdd.mock.t.Fatalf("ServiceMock.LineItemAdd mock is already set by Set")
	}

	expectation := &ServiceMockLineItemAddExpectation{
		mock:   mmLineItemAdd.mock,
		params: &ServiceMockLineItemAddParams{ctx, cartID, items},
	}
	mmLineItemAdd.expectations = append(mmLineItemAdd.expectations, expectation)
	return expectation
}

// Then sets up service.LineItemAdd return parameters for the expectation previously defined by the When method
func (e *ServiceMockLineItemAddExpectation) Then(lpa1 []*LineItem, err error) *ServiceMock {
	e.results = &ServiceMockLineItemAddResults{lpa1, err}
	return e.mock
}

// LineItemAdd implements service
func (mmLineItemAdd *ServiceMock) LineItemAdd(ctx context.Context, cartID int64, items []*LineItem) (lpa1 []*LineItem, err error) {
	mm_atomic.AddUint64(&mmLineItemAdd.beforeLineItemAddCounter, 1)
	defer mm_atomic.AddUint64(&mmLineItemAdd.afterLineItemAddCounter, 1)

	if mmLineItemAdd.inspectFuncLineItemAdd != nil {
		mmLineItemAdd.inspectFuncLineItemAdd(ctx, cartID, items)
	}

	mm_params := &ServiceMockLineItemAddParams{ctx, cartID, items}

	// Record call args
	mmLineItemAdd.LineItemAddMock.mutex.Lock()
	mmLineItemAdd.LineItemAddMock.callArgs = append(mmLineItemAdd.LineItemAddMock.callArgs, mm_params)
	mmLineItemAdd.LineItemAddMock.mutex.Unlock()

	for _, e := range mmLineItemAdd.LineItemAddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lpa1, e.results.err
		}
	}

	if mmLineItemAdd.LineItemAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLineItemAdd.LineItemAddMock.defaultExpectation.Counter, 1)
		mm_want := mmLineItemAdd.LineItemAddMock.defaultExpectation.params
		mm_got := ServiceMockLineItemAddParams{ctx, cartID, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLineItemAdd.t.Errorf("ServiceMock.LineItemAdd got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLineItemAdd.LineItemAddMock.defaultExpectation.results
		if mm_results == nil {
			mmLineItemAdd.t.Fatal("No results are set for the ServiceMock.LineItemAdd")
		}
		return (*mm_results).lpa1, (*mm_results).err
	}
	if mmLineItemAdd.funcLineItemAdd != nil {
		return mmLineItemAdd.funcLineItemAdd(ctx, cartID, items)
	}
	mmLineItemAdd.t.Fatalf("Unexpected call to ServiceMock.LineItemAdd. %v %v %v", ctx, cartID, items)
	return
}

// LineItemAddAfterCounter returns a count of finished ServiceMock.LineItemAdd invocations
func (mmLineItemAdd *ServiceMock) LineItemAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLineItemAdd.afterLineItemAddCounter)
}

// LineItemAddBeforeCounter returns a count of ServiceMock.LineItemAdd invocations
func (mmLineItemAdd *ServiceMock) LineItemAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLineItemAdd.beforeLineItemAddCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.LineItemAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLineItemAdd *mServiceMockLineItemAdd) Calls() []*ServiceMockLineItemAddParams {
	mmLineItemAdd.mutex.RLock()

	argCopy := make([]*ServiceMockLineItemAddParams, len(mmLineItemAdd.callArgs))
	copy(argCopy, mmLineItemAdd.callArgs)

	mmLineItemAdd.mutex.RUnlock()

	return argCopy
}

// MinimockLineItemAddDone returns true if the count of the LineItemAdd invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockLineItemAddDone() bool {
	for _, e := range m.LineItemAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LineItemAddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLineItemAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLineItemAdd != nil && mm_atomic.LoadUint64(&m.afterLineItemAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockLineItemAddInspect logs each unmet expectation
func (m *ServiceMock) MinimockLineItemAddInspect() {
	for _, e := range m.LineItemAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.LineItemAdd with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LineItemAddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLineItemAddCounter) < 1 {
		if m.LineItemAddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.LineItemAdd")
		} else {
			m.t.Errorf("Expected call to ServiceMock.LineItemAdd with params: %#v", *m.LineItemAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLineItemAdd != nil && mm_atomic.LoadUint64(&m.afterLineItemAddCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.LineItemAdd")
	}
}

type mServiceMockLineItemRemove struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockLineItemRemoveExpectation
	expectations       []*ServiceMockLineItemRemoveExpectation

	callArgs []*ServiceMockLineItemRemoveParams
	mutex    sync.RWMutex
}

// ServiceMockLineItemRemoveExpectation specifies expectation struct of the service.LineItemRemove
type ServiceMockLineItemRemoveExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockLineItemRemoveParams
	results *ServiceMockLineItemRemoveResults
	Counter uint64
}

// ServiceMockLineItemRemoveParams contains parameters of the service.LineItemRemove
type ServiceMockLineItemRemoveParams struct {
	ctx    context.Context
	cartID int64
	itemID int64
}

// ServiceMockLineItemRemoveResults contains results of the service.LineItemRemove
type ServiceMockLineItemRemoveResults struct {
	err error
}

// Expect sets up expected params for service.LineItemRemove
func (mmLineItemRemove *mServiceMockLineItemRemove) Expect(ctx context.Context, cartID int64, itemID int64) *mServiceMockLineItemRemove {
	if mmLineItemRemove.mock.funcLineItemRemove != nil {
		mmLineItemRemove.mock.t.Fatalf("ServiceMock.LineItemRemove mock is already set by Set")
	}

	if mmLineItemRemove.defaultExpectation == nil {
		mmLineItemRemove.defaultExpectation = &ServiceMockLineItemRemoveExpectation{}
	}

	mmLineItemRemove.defaultExpectation.params = &ServiceMockLineItemRemoveParams{ctx, cartID, itemID}
	for _, e := range mmLineItemRemove.expectations {
		if minimock.Equal(e.params, mmLineItemRemove.defaultExpectation.params) {
			mmLineItemRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLineItemRemove.defaultExpectation.params)
		}
	}

	return mmLineItemRemove
}

// Inspect accepts an inspector function that has same arguments as the service.LineItemRemove
func (mmLineItemRemove *mServiceMockLineItemRemove) Inspect(f func(ctx context.Context, cartID int64, itemID int64)) *mServiceMockLineItemRemove {
	if mmLineItemRemove.mock.inspectFuncLineItemRemove != nil {
		mmLineItemRemove.mock.t.Fatalf("Inspect function is already set for ServiceMock.LineItemRemove")
	}

	mmLineItemRemove.mock.inspectFuncLineItemRemove = f

	return mmLineItemRemove
}

// Return sets up results that will be returned by service.LineItemRemove
func (mmLineItemRemove *mServiceMockLineItemRemove) Return(err error) *ServiceMock {
	if mmLineItemRemove.mock.funcLineItemRemove != nil {
		mmLineItemRemove.mock.t.Fatalf("ServiceMock.LineItemRemove mock is already set by Set")
	}

	if mmLineItemRemove.defaultExpectation == nil {
		mmLineItemRemove.defaultExpectation = &ServiceMockLineItemRemoveExpectation{mock: mmLineItemRemove.mock}
	}
	mmLineItemRemove.defaultExpectation.results = &ServiceMockLineItemRemoveResults{err}
	return mmLineItemRemove.mock
}

//Set uses given function f to mock the service.LineItemRemove method
func (mmLineItemRemove *mServiceMockLineItemRemove) Set(f func(ctx context.Context, cartID int64, itemID int64) (err error)) *ServiceMock {
	if mmLineItemRemove.defaultExpectation != nil {
		mmLineItemRemove.mock.t.Fatalf("Default expectation is already set for the service.LineItemRemove method")
	}

	if len(mmLineItemRemove.expectations) > 0 {
		mmLineItemRemove.mock.t.Fatalf("Some expectations are already set for the service.LineItemRemove method")
	}

	mmLineItemRemove.mock.funcLineItemRemove = f
	return mmLineItemRemove.mock
}

// When sets expectation for the service.LineItemRemove which will trigger the result defined by the following
// Then helper
func (mmLineItemRemove *mServiceMockLineItemRemove) When(ctx context.Context, cartID int64, itemID int64) *ServiceMockLineItemRemoveExpectation {
	if mmLineItemRemove.mock.funcLineItemRemove != nil {
		mmLineItemRemove.mock.t.Fatalf("ServiceMock.LineItemRemove mock is already set by Set")
	}

	expectation := &ServiceMockLineItemRemoveExpectation{
		mock:   mmLineItemRemove.mock,
		params: &ServiceMockLineItemRemoveParams{ctx, cartID, itemID},
	}
	mmLineItemRemove.expectations = append(mmLineItemRemove.expectations, expectation)
	return expectation
}

// Then sets up service.LineItemRemove return parameters for the expectation previously defined by the When method
func (e *ServiceMockLineItemRemoveExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockLineItemRemoveResults{err}
	return e.mock
}

// LineItemRemove implements service
func (mmLineItemRemove *ServiceMock) LineItemRemove(ctx context.Context, cartID int64, itemID int64) (err error) {
	mm_atomic.AddUint64(&mmLineItemRemove.beforeLineItemRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmLineItemRemove.afterLineItemRemoveCounter, 1)

	if mmLineItemRemove.inspectFuncLineItemRemove != nil {
		mmLineItemRemove.inspectFuncLineItemRemove(ctx, cartID, itemID)
	}

	mm_params := &ServiceMockLineItemRemoveParams{ctx, cartID, itemID}

	// Record call args
	mmLineItemRemove.LineItemRemoveMock.mutex.Lock()
	mmLineItemRemove.LineItemRemoveMock.callArgs = append(mmLineItemRemove.LineItemRemoveMock.callArgs, mm_params)
	mmLineItemRemove.LineItemRemoveMock.mutex.Unlock()

	for _, e := range mmLineItemRemove.LineItemRemoveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLineItemRemove.LineItemRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLineItemRemove.LineItemRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmLineItemRemove.LineItemRemoveMock.defaultExpectation.params
		mm_got := ServiceMockLineItemRemoveParams{ctx, cartID, itemID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLineItemRemove.t.Errorf("ServiceMock.LineItemRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLineItemRemove.LineItemRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmLineItemRemove.t.Fatal("No results are set for the ServiceMock.LineItemRemove")
		}
		return (*mm_results).err
	}
	if mmLineItemRemove.funcLineItemRemove != nil {
		return mmLineItemRemove.funcLineItemRemove(ctx, cartID, itemID)
	}
	mmLineItemRemove.t.Fatalf("Unexpected call to ServiceMock.LineItemRemove. %v %v %v", ctx, cartID, itemID)
	return
}

// LineItemRemoveAfterCounter returns a count of finished ServiceMock.LineItemRemove invocations
func (mmLineItemRemove *ServiceMock) LineItemRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLineItemRemove.afterLineItemRemoveCounter)
}

// LineItemRemoveBeforeCounter returns a count of ServiceMock.LineItemRemove invocations
func (mmLineItemRemove *ServiceMock) LineItemRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLineItemRemove.beforeLineItemRemoveCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.LineItemRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLineItemRemove *mServiceMockLineItemRemove) Calls() []*ServiceMockLineItemRemoveParams {
	mmLineItemRemove.mutex.RLock()

	argCopy := make([]*ServiceMockLineItemRemoveParams, len(mmLineItemRemove.callArgs))
	copy(argCopy, mmLineItemRemove.callArgs)

	mmLineItemRemove.mutex.RUnlock()

	return argCopy
}

// MinimockLineItemRemoveDone returns true if the count of the LineItemRemove invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockLineItemRemoveDone() bool {
	for _, e := range m.LineItemRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LineItemRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLineItemRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLineItemRemove != nil && mm_atomic.LoadUint64(&m.afterLineItemRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockLineItemRemoveInspect logs each unmet expectation
func (m *ServiceMock) MinimockLineItemRemoveInspect() {
	for _, e := range m.LineItemRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.LineItemRemove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LineItemRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLineItemRemoveCounter) < 1 {
		if m.LineItemRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.LineItemRemove")
		} else {
			m.t.Errorf("Expected call to ServiceMock.LineItemRemove with params: %#v", *m.LineItemRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLineItemRemove != nil && mm_atomic.LoadUint64(&m.afterLineItemRemoveCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.LineItemRemove")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCartCreateInspect()

		m.MinimockCartEmptyInspect()

		m.MinimockCartShowInspect()

		m.MinimockLineItemAddInspect()

		m.MinimockLineItemRemoveInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCartCreateDone() &&
		m.MinimockCartEmptyDone() &&
		m.MinimockCartShowDone() &&
		m.MinimockLineItemAddDone() &&
		m.MinimockLineItemRemoveDone()
}
