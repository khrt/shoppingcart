package main

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i shoppingcart.storer -o ./storer_mock_test.go

import (
	"context"
	"database/sql"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorerMock implements storer
type StorerMock struct {
	t minimock.Tester

	funcBeginTx          func(ctx context.Context, opts *sql.TxOptions) (s1 storer, err error)
	inspectFuncBeginTx   func(ctx context.Context, opts *sql.TxOptions)
	afterBeginTxCounter  uint64
	beforeBeginTxCounter uint64
	BeginTxMock          mStorerMockBeginTx

	funcCartCreate          func(ctx context.Context, cart *Cart) (err error)
	inspectFuncCartCreate   func(ctx context.Context, cart *Cart)
	afterCartCreateCounter  uint64
	beforeCartCreateCounter uint64
	CartCreateMock          mStorerMockCartCreate

	funcCartEmpty          func(ctx context.Context, cartID int64) (err error)
	inspectFuncCartEmpty   func(ctx context.Context, cartID int64)
	afterCartEmptyCounter  uint64
	beforeCartEmptyCounter uint64
	CartEmptyMock          mStorerMockCartEmpty

	funcCartWithItemsByCartID          func(ctx context.Context, cartID int64) (cp1 *Cart, err error)
	inspectFuncCartWithItemsByCartID   func(ctx context.Context, cartID int64)
	afterCartWithItemsByCartIDCounter  uint64
	beforeCartWithItemsByCartIDCounter uint64
	CartWithItemsByCartIDMock          mStorerMockCartWithItemsByCartID

	funcCommit          func() (err error)
	inspectFuncCommit   func()
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mStorerMockCommit

	funcLineItemRemove          func(ctx context.Context, cartID int64, itemID int64) (err error)
	inspectFuncLineItemRemove   func(ctx context.Context, cartID int64, itemID int64)
	afterLineItemRemoveCounter  uint64
	beforeLineItemRemoveCounter uint64
	LineItemRemoveMock          mStorerMockLineItemRemove

	funcLineItemsUpsert          func(ctx context.Context, cartID int64, items ...*LineItem) (err error)
	inspectFuncLineItemsUpsert   func(ctx context.Context, cartID int64, items ...*LineItem)
	afterLineItemsUpsertCounter  uint64
	beforeLineItemsUpsertCounter uint64
	LineItemsUpsertMock          mStorerMockLineItemsUpsert
}

// NewStorerMock returns a mock for storer
func NewStorerMock(t minimock.Tester) *StorerMock {
	m := &StorerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginTxMock = mStorerMockBeginTx{mock: m}
	m.BeginTxMock.callArgs = []*StorerMockBeginTxParams{}

	m.CartCreateMock = mStorerMockCartCreate{mock: m}
	m.CartCreateMock.callArgs = []*StorerMockCartCreateParams{}

	m.CartEmptyMock = mStorerMockCartEmpty{mock: m}
	m.CartEmptyMock.callArgs = []*StorerMockCartEmptyParams{}

	m.CartWithItemsByCartIDMock = mStorerMockCartWithItemsByCartID{mock: m}
	m.CartWithItemsByCartIDMock.callArgs = []*StorerMockCartWithItemsByCartIDParams{}

	m.CommitMock = mStorerMockCommit{mock: m}

	m.LineItemRemoveMock = mStorerMockLineItemRemove{mock: m}
	m.LineItemRemoveMock.callArgs = []*StorerMockLineItemRemoveParams{}

	m.LineItemsUpsertMock = mStorerMockLineItemsUpsert{mock: m}
	m.LineItemsUpsertMock.callArgs = []*StorerMockLineItemsUpsertParams{}

	return m
}

type mStorerMockBeginTx struct {
	mock               *StorerMock
	defaultExpectation *StorerMockBeginTxExpectation
	expectations       []*StorerMockBeginTxExpectation

	callArgs []*StorerMockBeginTxParams
	mutex    sync.RWMutex
}

// StorerMockBeginTxExpectation specifies expectation struct of the storer.BeginTx
type StorerMockBeginTxExpectation struct {
	mock    *StorerMock
	params  *StorerMockBeginTxParams
	results *StorerMockBeginTxResults
	Counter uint64
}

// StorerMockBeginTxParams contains parameters of the storer.BeginTx
type StorerMockBeginTxParams struct {
	ctx  context.Context
	opts *sql.TxOptions
}

// StorerMockBeginTxResults contains results of the storer.BeginTx
type StorerMockBeginTxResults struct {
	s1  storer
	err error
}

// Expect sets up expected params for storer.BeginTx
func (mmBeginTx *mStorerMockBeginTx) Expect(ctx context.Context, opts *sql.TxOptions) *mStorerMockBeginTx {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("StorerMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &StorerMockBeginTxExpectation{}
	}

	mmBeginTx.defaultExpectation.params = &StorerMockBeginTxParams{ctx, opts}
	for _, e := range mmBeginTx.expectations {
		if minimock.Equal(e.params, mmBeginTx.defaultExpectation.params) {
			mmBeginTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginTx.defaultExpectation.params)
		}
	}

	return mmBeginTx
}

// Inspect accepts an inspector function that has same arguments as the storer.BeginTx
func (mmBeginTx *mStorerMockBeginTx) Inspect(f func(ctx context.Context, opts *sql.TxOptions)) *mStorerMockBeginTx {
	if mmBeginTx.mock.inspectFuncBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("Inspect function is already set for StorerMock.BeginTx")
	}

	mmBeginTx.mock.inspectFuncBeginTx = f

	return mmBeginTx
}

// Return sets up results that will be returned by storer.BeginTx
func (mmBeginTx *mStorerMockBeginTx) Return(s1 storer, err error) *StorerMock {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("StorerMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &StorerMockBeginTxExpectation{mock: mmBeginTx.mock}
	}
	mmBeginTx.defaultExpectation.results = &StorerMockBeginTxResults{s1, err}
	return mmBeginTx.mock
}

//Set uses given function f to mock the storer.BeginTx method
func (mmBeginTx *mStorerMockBeginTx) Set(f func(ctx context.Context, opts *sql.TxOptions) (s1 storer, err error)) *StorerMock {
	if mmBeginTx.defaultExpectation != nil {
		mmBeginTx.mock.t.Fatalf("Default expectation is already set for the storer.BeginTx method")
	}

	if len(mmBeginTx.expectations) > 0 {
		mmBeginTx.mock.t.Fatalf("Some expectations are already set for the storer.BeginTx method")
	}

	mmBeginTx.mock.funcBeginTx = f
	return mmBeginTx.mock
}

// When sets expectation for the storer.BeginTx which will trigger the result defined by the following
// Then helper
func (mmBeginTx *mStorerMockBeginTx) When(ctx context.Context, opts *sql.TxOptions) *StorerMockBeginTxExpectation {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("StorerMock.BeginTx mock is already set by Set")
	}

	expectation := &StorerMockBeginTxExpectation{
		mock:   mmBeginTx.mock,
		params: &StorerMockBeginTxParams{ctx, opts},
	}
	mmBeginTx.expectations = append(mmBeginTx.expectations, expectation)
	return expectation
}

// Then sets up storer.BeginTx return parameters for the expectation previously defined by the When method
func (e *StorerMockBeginTxExpectation) Then(s1 storer, err error) *StorerMock {
	e.results = &StorerMockBeginTxResults{s1, err}
	return e.mock
}

// BeginTx implements storer
func (mmBeginTx *StorerMock) BeginTx(ctx context.Context, opts *sql.TxOptions) (s1 storer, err error) {
	mm_atomic.AddUint64(&mmBeginTx.beforeBeginTxCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginTx.afterBeginTxCounter, 1)

	if mmBeginTx.inspectFuncBeginTx != nil {
		mmBeginTx.inspectFuncBeginTx(ctx, opts)
	}

	mm_params := &StorerMockBeginTxParams{ctx, opts}

	// Record call args
	mmBeginTx.BeginTxMock.mutex.Lock()
	mmBeginTx.BeginTxMock.callArgs = append(mmBeginTx.BeginTxMock.callArgs, mm_params)
	mmBeginTx.BeginTxMock.mutex.Unlock()

	for _, e := range mmBeginTx.BeginTxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmBeginTx.BeginTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginTx.BeginTxMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginTx.BeginTxMock.defaultExpectation.params
		mm_got := StorerMockBeginTxParams{ctx, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginTx.t.Errorf("StorerMock.BeginTx got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginTx.BeginTxMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginTx.t.Fatal("No results are set for the StorerMock.BeginTx")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmBeginTx.funcBeginTx != nil {
		return mmBeginTx.funcBeginTx(ctx, opts)
	}
	mmBeginTx.t.Fatalf("Unexpected call to StorerMock.BeginTx. %v %v", ctx, opts)
	return
}

// BeginTxAfterCounter returns a count of finished StorerMock.BeginTx invocations
func (mmBeginTx *StorerMock) BeginTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.afterBeginTxCounter)
}

// BeginTxBeforeCounter returns a count of StorerMock.BeginTx invocations
func (mmBeginTx *StorerMock) BeginTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.beforeBeginTxCounter)
}

// Calls returns a list of arguments used in each call to StorerMock.BeginTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginTx *mStorerMockBeginTx) Calls() []*StorerMockBeginTxParams {
	mmBeginTx.mutex.RLock()

	argCopy := make([]*StorerMockBeginTxParams, len(mmBeginTx.callArgs))
	copy(argCopy, mmBeginTx.callArgs)

	mmBeginTx.mutex.RUnlock()

	return argCopy
}

// MinimockBeginTxDone returns true if the count of the BeginTx invocations corresponds
// the number of defined expectations
func (m *StorerMock) MinimockBeginTxDone() bool {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginTxInspect logs each unmet expectation
func (m *StorerMock) MinimockBeginTxInspect() {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorerMock.BeginTx with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		if m.BeginTxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorerMock.BeginTx")
		} else {
			m.t.Errorf("Expected call to StorerMock.BeginTx with params: %#v", *m.BeginTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		m.t.Error("Expected call to StorerMock.BeginTx")
	}
}

type mStorerMockCartCreate struct {
	mock               *StorerMock
	defaultExpectation *StorerMockCartCreateExpectation
	expectations       []*StorerMockCartCreateExpectation

	callArgs []*StorerMockCartCreateParams
	mutex    sync.RWMutex
}

// StorerMockCartCreateExpectation specifies expectation struct of the storer.CartCreate
type StorerMockCartCreateExpectation struct {
	mock    *StorerMock
	params  *StorerMockCartCreateParams
	results *StorerMockCartCreateResults
	Counter uint64
}

// StorerMockCartCreateParams contains parameters of the storer.CartCreate
type StorerMockCartCreateParams struct {
	ctx  context.Context
	cart *Cart
}

// StorerMockCartCreateResults contains results of the storer.CartCreate
type StorerMockCartCreateResults struct {
	err error
}

// Expect sets up expected params for storer.CartCreate
func (mmCartCreate *mStorerMockCartCreate) Expect(ctx context.Context, cart *Cart) *mStorerMockCartCreate {
	if mmCartCreate.mock.funcCartCreate != nil {
		mmCartCreate.mock.t.Fatalf("StorerMock.CartCreate mock is already set by Set")
	}

	if mmCartCreate.defaultExpectation == nil {
		mmCartCreate.defaultExpectation = &StorerMockCartCreateExpectation{}
	}

	mmCartCreate.defaultExpectation.params = &StorerMockCartCreateParams{ctx, cart}
	for _, e := range mmCartCreate.expectations {
		if minimock.Equal(e.params, mmCartCreate.defaultExpectation.params) {
			mmCartCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCartCreate.defaultExpectation.params)
		}
	}

	return mmCartCreate
}

// Inspect accepts an inspector function that has same arguments as the storer.CartCreate
func (mmCartCreate *mStorerMockCartCreate) Inspect(f func(ctx context.Context, cart *Cart)) *mStorerMockCartCreate {
	if mmCartCreate.mock.inspectFuncCartCreate != nil {
		mmCartCreate.mock.t.Fatalf("Inspect function is already set for StorerMock.CartCreate")
	}

	mmCartCreate.mock.inspectFuncCartCreate = f

	return mmCartCreate
}

// Return sets up results that will be returned by storer.CartCreate
func (mmCartCreate *mStorerMockCartCreate) Return(err error) *StorerMock {
	if mmCartCreate.mock.funcCartCreate != nil {
		mmCartCreate.mock.t.Fatalf("StorerMock.CartCreate mock is already set by Set")
	}

	if mmCartCreate.defaultExpectation == nil {
		mmCartCreate.defaultExpectation = &StorerMockCartCreateExpectation{mock: mmCartCreate.mock}
	}
	mmCartCreate.defaultExpectation.results = &StorerMockCartCreateResults{err}
	return mmCartCreate.mock
}

//Set uses given function f to mock the storer.CartCreate method
func (mmCartCreate *mStorerMockCartCreate) Set(f func(ctx context.Context, cart *Cart) (err error)) *StorerMock {
	if mmCartCreate.defaultExpectation != nil {
		mmCartCreate.mock.t.Fatalf("Default expectation is already set for the storer.CartCreate method")
	}

	if len(mmCartCreate.expectations) > 0 {
		mmCartCreate.mock.t.Fatalf("Some expectations are already set for the storer.CartCreate method")
	}

	mmCartCreate.mock.funcCartCreate = f
	return mmCartCreate.mock
}

// When sets expectation for the storer.CartCreate which will trigger the result defined by the following
// Then helper
func (mmCartCreate *mStorerMockCartCreate) When(ctx context.Context, cart *Cart) *StorerMockCartCreateExpectation {
	if mmCartCreate.mock.funcCartCreate != nil {
		mmCartCreate.mock.t.Fatalf("StorerMock.CartCreate mock is already set by Set")
	}

	expectation := &StorerMockCartCreateExpectation{
		mock:   mmCartCreate.mock,
		params: &StorerMockCartCreateParams{ctx, cart},
	}
	mmCartCreate.expectations = append(mmCartCreate.expectations, expectation)
	return expectation
}

// Then sets up storer.CartCreate return parameters for the expectation previously defined by the When method
func (e *StorerMockCartCreateExpectation) Then(err error) *StorerMock {
	e.results = &StorerMockCartCreateResults{err}
	return e.mock
}

// CartCreate implements storer
func (mmCartCreate *StorerMock) CartCreate(ctx context.Context, cart *Cart) (err error) {
	mm_atomic.AddUint64(&mmCartCreate.beforeCartCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCartCreate.afterCartCreateCounter, 1)

	if mmCartCreate.inspectFuncCartCreate != nil {
		mmCartCreate.inspectFuncCartCreate(ctx, cart)
	}

	mm_params := &StorerMockCartCreateParams{ctx, cart}

	// Record call args
	mmCartCreate.CartCreateMock.mutex.Lock()
	mmCartCreate.CartCreateMock.callArgs = append(mmCartCreate.CartCreateMock.callArgs, mm_params)
	mmCartCreate.CartCreateMock.mutex.Unlock()

	for _, e := range mmCartCreate.CartCreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCartCreate.CartCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCartCreate.CartCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCartCreate.CartCreateMock.defaultExpectation.params
		mm_got := StorerMockCartCreateParams{ctx, cart}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCartCreate.t.Errorf("StorerMock.CartCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCartCreate.CartCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCartCreate.t.Fatal("No results are set for the StorerMock.CartCreate")
		}
		return (*mm_results).err
	}
	if mmCartCreate.funcCartCreate != nil {
		return mmCartCreate.funcCartCreate(ctx, cart)
	}
	mmCartCreate.t.Fatalf("Unexpected call to StorerMock.CartCreate. %v %v", ctx, cart)
	return
}

// CartCreateAfterCounter returns a count of finished StorerMock.CartCreate invocations
func (mmCartCreate *StorerMock) CartCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartCreate.afterCartCreateCounter)
}

// CartCreateBeforeCounter returns a count of StorerMock.CartCreate invocations
func (mmCartCreate *StorerMock) CartCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartCreate.beforeCartCreateCounter)
}

// Calls returns a list of arguments used in each call to StorerMock.CartCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCartCreate *mStorerMockCartCreate) Calls() []*StorerMockCartCreateParams {
	mmCartCreate.mutex.RLock()

	argCopy := make([]*StorerMockCartCreateParams, len(mmCartCreate.callArgs))
	copy(argCopy, mmCartCreate.callArgs)

	mmCartCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCartCreateDone returns true if the count of the CartCreate invocations corresponds
// the number of defined expectations
func (m *StorerMock) MinimockCartCreateDone() bool {
	for _, e := range m.CartCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartCreate != nil && mm_atomic.LoadUint64(&m.afterCartCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCartCreateInspect logs each unmet expectation
func (m *StorerMock) MinimockCartCreateInspect() {
	for _, e := range m.CartCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorerMock.CartCreate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartCreateCounter) < 1 {
		if m.CartCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorerMock.CartCreate")
		} else {
			m.t.Errorf("Expected call to StorerMock.CartCreate with params: %#v", *m.CartCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartCreate != nil && mm_atomic.LoadUint64(&m.afterCartCreateCounter) < 1 {
		m.t.Error("Expected call to StorerMock.CartCreate")
	}
}

type mStorerMockCartEmpty struct {
	mock               *StorerMock
	defaultExpectation *StorerMockCartEmptyExpectation
	expectations       []*StorerMockCartEmptyExpectation

	callArgs []*StorerMockCartEmptyParams
	mutex    sync.RWMutex
}

// StorerMockCartEmptyExpectation specifies expectation struct of the storer.CartEmpty
type StorerMockCartEmptyExpectation struct {
	mock    *StorerMock
	params  *StorerMockCartEmptyParams
	results *StorerMockCartEmptyResults
	Counter uint64
}

// StorerMockCartEmptyParams contains parameters of the storer.CartEmpty
type StorerMockCartEmptyParams struct {
	ctx    context.Context
	cartID int64
}

// StorerMockCartEmptyResults contains results of the storer.CartEmpty
type StorerMockCartEmptyResults struct {
	err error
}

// Expect sets up expected params for storer.CartEmpty
func (mmCartEmpty *mStorerMockCartEmpty) Expect(ctx context.Context, cartID int64) *mStorerMockCartEmpty {
	if mmCartEmpty.mock.funcCartEmpty != nil {
		mmCartEmpty.mock.t.Fatalf("StorerMock.CartEmpty mock is already set by Set")
	}

	if mmCartEmpty.defaultExpectation == nil {
		mmCartEmpty.defaultExpectation = &StorerMockCartEmptyExpectation{}
	}

	mmCartEmpty.defaultExpectation.params = &StorerMockCartEmptyParams{ctx, cartID}
	for _, e := range mmCartEmpty.expectations {
		if minimock.Equal(e.params, mmCartEmpty.defaultExpectation.params) {
			mmCartEmpty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCartEmpty.defaultExpectation.params)
		}
	}

	return mmCartEmpty
}

// Inspect accepts an inspector function that has same arguments as the storer.CartEmpty
func (mmCartEmpty *mStorerMockCartEmpty) Inspect(f func(ctx context.Context, cartID int64)) *mStorerMockCartEmpty {
	if mmCartEmpty.mock.inspectFuncCartEmpty != nil {
		mmCartEmpty.mock.t.Fatalf("Inspect function is already set for StorerMock.CartEmpty")
	}

	mmCartEmpty.mock.inspectFuncCartEmpty = f

	return mmCartEmpty
}

// Return sets up results that will be returned by storer.CartEmpty
func (mmCartEmpty *mStorerMockCartEmpty) Return(err error) *StorerMock {
	if mmCartEmpty.mock.funcCartEmpty != nil {
		mmCartEmpty.mock.t.Fatalf("StorerMock.CartEmpty mock is already set by Set")
	}

	if mmCartEmpty.defaultExpectation == nil {
		mmCartEmpty.defaultExpectation = &StorerMockCartEmptyExpectation{mock: mmCartEmpty.mock}
	}
	mmCartEmpty.defaultExpectation.results = &StorerMockCartEmptyResults{err}
	return mmCartEmpty.mock
}

//Set uses given function f to mock the storer.CartEmpty method
func (mmCartEmpty *mStorerMockCartEmpty) Set(f func(ctx context.Context, cartID int64) (err error)) *StorerMock {
	if mmCartEmpty.defaultExpectation != nil {
		mmCartEmpty.mock.t.Fatalf("Default expectation is already set for the storer.CartEmpty method")
	}

	if len(mmCartEmpty.expectations) > 0 {
		mmCartEmpty.mock.t.Fatalf("Some expectations are already set for the storer.CartEmpty method")
	}

	mmCartEmpty.mock.funcCartEmpty = f
	return mmCartEmpty.mock
}

// When sets expectation for the storer.CartEmpty which will trigger the result defined by the following
// Then helper
func (mmCartEmpty *mStorerMockCartEmpty) When(ctx context.Context, cartID int64) *StorerMockCartEmptyExpectation {
	if mmCartEmpty.mock.funcCartEmpty != nil {
		mmCartEmpty.mock.t.Fatalf("StorerMock.CartEmpty mock is already set by Set")
	}

	expectation := &StorerMockCartEmptyExpectation{
		mock:   mmCartEmpty.mock,
		params: &StorerMockCartEmptyParams{ctx, cartID},
	}
	mmCartEmpty.expectations = append(mmCartEmpty.expectations, expectation)
	return expectation
}

// Then sets up storer.CartEmpty return parameters for the expectation previously defined by the When method
func (e *StorerMockCartEmptyExpectation) Then(err error) *StorerMock {
	e.results = &StorerMockCartEmptyResults{err}
	return e.mock
}

// CartEmpty implements storer
func (mmCartEmpty *StorerMock) CartEmpty(ctx context.Context, cartID int64) (err error) {
	mm_atomic.AddUint64(&mmCartEmpty.beforeCartEmptyCounter, 1)
	defer mm_atomic.AddUint64(&mmCartEmpty.afterCartEmptyCounter, 1)

	if mmCartEmpty.inspectFuncCartEmpty != nil {
		mmCartEmpty.inspectFuncCartEmpty(ctx, cartID)
	}

	mm_params := &StorerMockCartEmptyParams{ctx, cartID}

	// Record call args
	mmCartEmpty.CartEmptyMock.mutex.Lock()
	mmCartEmpty.CartEmptyMock.callArgs = append(mmCartEmpty.CartEmptyMock.callArgs, mm_params)
	mmCartEmpty.CartEmptyMock.mutex.Unlock()

	for _, e := range mmCartEmpty.CartEmptyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCartEmpty.CartEmptyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCartEmpty.CartEmptyMock.defaultExpectation.Counter, 1)
		mm_want := mmCartEmpty.CartEmptyMock.defaultExpectation.params
		mm_got := StorerMockCartEmptyParams{ctx, cartID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCartEmpty.t.Errorf("StorerMock.CartEmpty got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCartEmpty.CartEmptyMock.defaultExpectation.results
		if mm_results == nil {
			mmCartEmpty.t.Fatal("No results are set for the StorerMock.CartEmpty")
		}
		return (*mm_results).err
	}
	if mmCartEmpty.funcCartEmpty != nil {
		return mmCartEmpty.funcCartEmpty(ctx, cartID)
	}
	mmCartEmpty.t.Fatalf("Unexpected call to StorerMock.CartEmpty. %v %v", ctx, cartID)
	return
}

// CartEmptyAfterCounter returns a count of finished StorerMock.CartEmpty invocations
func (mmCartEmpty *StorerMock) CartEmptyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartEmpty.afterCartEmptyCounter)
}

// CartEmptyBeforeCounter returns a count of StorerMock.CartEmpty invocations
func (mmCartEmpty *StorerMock) CartEmptyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartEmpty.beforeCartEmptyCounter)
}

// Calls returns a list of arguments used in each call to StorerMock.CartEmpty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCartEmpty *mStorerMockCartEmpty) Calls() []*StorerMockCartEmptyParams {
	mmCartEmpty.mutex.RLock()

	argCopy := make([]*StorerMockCartEmptyParams, len(mmCartEmpty.callArgs))
	copy(argCopy, mmCartEmpty.callArgs)

	mmCartEmpty.mutex.RUnlock()

	return argCopy
}

// MinimockCartEmptyDone returns true if the count of the CartEmpty invocations corresponds
// the number of defined expectations
func (m *StorerMock) MinimockCartEmptyDone() bool {
	for _, e := range m.CartEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartEmptyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartEmpty != nil && mm_atomic.LoadUint64(&m.afterCartEmptyCounter) < 1 {
		return false
	}
	return true
}

// MinimockCartEmptyInspect logs each unmet expectation
func (m *StorerMock) MinimockCartEmptyInspect() {
	for _, e := range m.CartEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorerMock.CartEmpty with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartEmptyCounter) < 1 {
		if m.CartEmptyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorerMock.CartEmpty")
		} else {
			m.t.Errorf("Expected call to StorerMock.CartEmpty with params: %#v", *m.CartEmptyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartEmpty != nil && mm_atomic.LoadUint64(&m.afterCartEmptyCounter) < 1 {
		m.t.Error("Expected call to StorerMock.CartEmpty")
	}
}

type mStorerMockCartWithItemsByCartID struct {
	mock               *StorerMock
	defaultExpectation *StorerMockCartWithItemsByCartIDExpectation
	expectations       []*StorerMockCartWithItemsByCartIDExpectation

	callArgs []*StorerMockCartWithItemsByCartIDParams
	mutex    sync.RWMutex
}

// StorerMockCartWithItemsByCartIDExpectation specifies expectation struct of the storer.CartWithItemsByCartID
type StorerMockCartWithItemsByCartIDExpectation struct {
	mock    *StorerMock
	params  *StorerMockCartWithItemsByCartIDParams
	results *StorerMockCartWithItemsByCartIDResults
	Counter uint64
}

// StorerMockCartWithItemsByCartIDParams contains parameters of the storer.CartWithItemsByCartID
type StorerMockCartWithItemsByCartIDParams struct {
	ctx    context.Context
	cartID int64
}

// StorerMockCartWithItemsByCartIDResults contains results of the storer.CartWithItemsByCartID
type StorerMockCartWithItemsByCartIDResults struct {
	cp1 *Cart
	err error
}

// Expect sets up expected params for storer.CartWithItemsByCartID
func (mmCartWithItemsByCartID *mStorerMockCartWithItemsByCartID) Expect(ctx context.Context, cartID int64) *mStorerMockCartWithItemsByCartID {
	if mmCartWithItemsByCartID.mock.funcCartWithItemsByCartID != nil {
		mmCartWithItemsByCartID.mock.t.Fatalf("StorerMock.CartWithItemsByCartID mock is already set by Set")
	}

	if mmCartWithItemsByCartID.defaultExpectation == nil {
		mmCartWithItemsByCartID.defaultExpectation = &StorerMockCartWithItemsByCartIDExpectation{}
	}

	mmCartWithItemsByCartID.defaultExpectation.params = &StorerMockCartWithItemsByCartIDParams{ctx, cartID}
	for _, e := range mmCartWithItemsByCartID.expectations {
		if minimock.Equal(e.params, mmCartWithItemsByCartID.defaultExpectation.params) {
			mmCartWithItemsByCartID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCartWithItemsByCartID.defaultExpectation.params)
		}
	}

	return mmCartWithItemsByCartID
}

// Inspect accepts an inspector function that has same arguments as the storer.CartWithItemsByCartID
func (mmCartWithItemsByCartID *mStorerMockCartWithItemsByCartID) Inspect(f func(ctx context.Context, cartID int64)) *mStorerMockCartWithItemsByCartID {
	if mmCartWithItemsByCartID.mock.inspectFuncCartWithItemsByCartID != nil {
		mmCartWithItemsByCartID.mock.t.Fatalf("Inspect function is already set for StorerMock.CartWithItemsByCartID")
	}

	mmCartWithItemsByCartID.mock.inspectFuncCartWithItemsByCartID = f

	return mmCartWithItemsByCartID
}

// Return sets up results that will be returned by storer.CartWithItemsByCartID
func (mmCartWithItemsByCartID *mStorerMockCartWithItemsByCartID) Return(cp1 *Cart, err error) *StorerMock {
	if mmCartWithItemsByCartID.mock.funcCartWithItemsByCartID != nil {
		mmCartWithItemsByCartID.mock.t.Fatalf("StorerMock.CartWithItemsByCartID mock is already set by Set")
	}

	if mmCartWithItemsByCartID.defaultExpectation == nil {
		mmCartWithItemsByCartID.defaultExpectation = &StorerMockCartWithItemsByCartIDExpectation{mock: mmCartWithItemsByCartID.mock}
	}
	mmCartWithItemsByCartID.defaultExpectation.results = &StorerMockCartWithItemsByCartIDResults{cp1, err}
	return mmCartWithItemsByCartID.mock
}

//Set uses given function f to mock the storer.CartWithItemsByCartID method
func (mmCartWithItemsByCartID *mStorerMockCartWithItemsByCartID) Set(f func(ctx context.Context, cartID int64) (cp1 *Cart, err error)) *StorerMock {
	if mmCartWithItemsByCartID.defaultExpectation != nil {
		mmCartWithItemsByCartID.mock.t.Fatalf("Default expectation is already set for the storer.CartWithItemsByCartID method")
	}

	if len(mmCartWithItemsByCartID.expectations) > 0 {
		mmCartWithItemsByCartID.mock.t.Fatalf("Some expectations are already set for the storer.CartWithItemsByCartID method")
	}

	mmCartWithItemsByCartID.mock.funcCartWithItemsByCartID = f
	return mmCartWithItemsByCartID.mock
}

// When sets expectation for the storer.CartWithItemsByCartID which will trigger the result defined by the following
// Then helper
func (mmCartWithItemsByCartID *mStorerMockCartWithItemsByCartID) When(ctx context.Context, cartID int64) *StorerMockCartWithItemsByCartIDExpectation {
	if mmCartWithItemsByCartID.mock.funcCartWithItemsByCartID != nil {
		mmCartWithItemsByCartID.mock.t.Fatalf("StorerMock.CartWithItemsByCartID mock is already set by Set")
	}

	expectation := &StorerMockCartWithItemsByCartIDExpectation{
		mock:   mmCartWithItemsByCartID.mock,
		params: &StorerMockCartWithItemsByCartIDParams{ctx, cartID},
	}
	mmCartWithItemsByCartID.expectations = append(mmCartWithItemsByCartID.expectations, expectation)
	return expectation
}

// Then sets up storer.CartWithItemsByCartID return parameters for the expectation previously defined by the When method
func (e *StorerMockCartWithItemsByCartIDExpectation) Then(cp1 *Cart, err error) *StorerMock {
	e.results = &StorerMockCartWithItemsByCartIDResults{cp1, err}
	return e.mock
}

// CartWithItemsByCartID implements storer
func (mmCartWithItemsByCartID *StorerMock) CartWithItemsByCartID(ctx context.Context, cartID int64) (cp1 *Cart, err error) {
	mm_atomic.AddUint64(&mmCartWithItemsByCartID.beforeCartWithItemsByCartIDCounter, 1)
	defer mm_atomic.AddUint64(&mmCartWithItemsByCartID.afterCartWithItemsByCartIDCounter, 1)

	if mmCartWithItemsByCartID.inspectFuncCartWithItemsByCartID != nil {
		mmCartWithItemsByCartID.inspectFuncCartWithItemsByCartID(ctx, cartID)
	}

	mm_params := &StorerMockCartWithItemsByCartIDParams{ctx, cartID}

	// Record call args
	mmCartWithItemsByCartID.CartWithItemsByCartIDMock.mutex.Lock()
	mmCartWithItemsByCartID.CartWithItemsByCartIDMock.callArgs = append(mmCartWithItemsByCartID.CartWithItemsByCartIDMock.callArgs, mm_params)
	mmCartWithItemsByCartID.CartWithItemsByCartIDMock.mutex.Unlock()

	for _, e := range mmCartWithItemsByCartID.CartWithItemsByCartIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCartWithItemsByCartID.CartWithItemsByCartIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCartWithItemsByCartID.CartWithItemsByCartIDMock.defaultExpectation.Counter, 1)
		mm_want := mmCartWithItemsByCartID.CartWithItemsByCartIDMock.defaultExpectation.params
		mm_got := StorerMockCartWithItemsByCartIDParams{ctx, cartID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCartWithItemsByCartID.t.Errorf("StorerMock.CartWithItemsByCartID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCartWithItemsByCartID.CartWithItemsByCartIDMock.defaultExpectation.results
		if mm_results == nil {
			mmCartWithItemsByCartID.t.Fatal("No results are set for the StorerMock.CartWithItemsByCartID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCartWithItemsByCartID.funcCartWithItemsByCartID != nil {
		return mmCartWithItemsByCartID.funcCartWithItemsByCartID(ctx, cartID)
	}
	mmCartWithItemsByCartID.t.Fatalf("Unexpected call to StorerMock.CartWithItemsByCartID. %v %v", ctx, cartID)
	return
}

// CartWithItemsByCartIDAfterCounter returns a count of finished StorerMock.CartWithItemsByCartID invocations
func (mmCartWithItemsByCartID *StorerMock) CartWithItemsByCartIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartWithItemsByCartID.afterCartWithItemsByCartIDCounter)
}

// CartWithItemsByCartIDBeforeCounter returns a count of StorerMock.CartWithItemsByCartID invocations
func (mmCartWithItemsByCartID *StorerMock) CartWithItemsByCartIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCartWithItemsByCartID.beforeCartWithItemsByCartIDCounter)
}

// Calls returns a list of arguments used in each call to StorerMock.CartWithItemsByCartID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCartWithItemsByCartID *mStorerMockCartWithItemsByCartID) Calls() []*StorerMockCartWithItemsByCartIDParams {
	mmCartWithItemsByCartID.mutex.RLock()

	argCopy := make([]*StorerMockCartWithItemsByCartIDParams, len(mmCartWithItemsByCartID.callArgs))
	copy(argCopy, mmCartWithItemsByCartID.callArgs)

	mmCartWithItemsByCartID.mutex.RUnlock()

	return argCopy
}

// MinimockCartWithItemsByCartIDDone returns true if the count of the CartWithItemsByCartID invocations corresponds
// the number of defined expectations
func (m *StorerMock) MinimockCartWithItemsByCartIDDone() bool {
	for _, e := range m.CartWithItemsByCartIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartWithItemsByCartIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartWithItemsByCartIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartWithItemsByCartID != nil && mm_atomic.LoadUint64(&m.afterCartWithItemsByCartIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockCartWithItemsByCartIDInspect logs each unmet expectation
func (m *StorerMock) MinimockCartWithItemsByCartIDInspect() {
	for _, e := range m.CartWithItemsByCartIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorerMock.CartWithItemsByCartID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CartWithItemsByCartIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCartWithItemsByCartIDCounter) < 1 {
		if m.CartWithItemsByCartIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorerMock.CartWithItemsByCartID")
		} else {
			m.t.Errorf("Expected call to StorerMock.CartWithItemsByCartID with params: %#v", *m.CartWithItemsByCartIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCartWithItemsByCartID != nil && mm_atomic.LoadUint64(&m.afterCartWithItemsByCartIDCounter) < 1 {
		m.t.Error("Expected call to StorerMock.CartWithItemsByCartID")
	}
}

type mStorerMockCommit struct {
	mock               *StorerMock
	defaultExpectation *StorerMockCommitExpectation
	expectations       []*StorerMockCommitExpectation
}

// StorerMockCommitExpectation specifies expectation struct of the storer.Commit
type StorerMockCommitExpectation struct {
	mock *StorerMock

	results *StorerMockCommitResults
	Counter uint64
}

// StorerMockCommitResults contains results of the storer.Commit
type StorerMockCommitResults struct {
	err error
}

// Expect sets up expected params for storer.Commit
func (mmCommit *mStorerMockCommit) Expect() *mStorerMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("StorerMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &StorerMockCommitExpectation{}
	}

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the storer.Commit
func (mmCommit *mStorerMockCommit) Inspect(f func()) *mStorerMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for StorerMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by storer.Commit
func (mmCommit *mStorerMockCommit) Return(err error) *StorerMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("StorerMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &StorerMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &StorerMockCommitResults{err}
	return mmCommit.mock
}

//Set uses given function f to mock the storer.Commit method
func (mmCommit *mStorerMockCommit) Set(f func() (err error)) *StorerMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the storer.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the storer.Commit method")
	}

	mmCommit.mock.funcCommit = f
	return mmCommit.mock
}

// Commit implements storer
func (mmCommit *StorerMock) Commit() (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit()
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the StorerMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit()
	}
	mmCommit.t.Fatalf("Unexpected call to StorerMock.Commit.")
	return
}

// CommitAfterCounter returns a count of finished StorerMock.Commit invocations
func (mmCommit *StorerMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of StorerMock.Commit invocations
func (mmCommit *StorerMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *StorerMock) MinimockCommitDone() bool {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitInspect logs each unmet expectation
func (m *StorerMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorerMock.Commit")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to StorerMock.Commit")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to StorerMock.Commit")
	}
}

type mStorerMockLineItemRemove struct {
	mock               *StorerMock
	defaultExpectation *StorerMockLineItemRemoveExpectation
	expectations       []*StorerMockLineItemRemoveExpectation

	callArgs []*StorerMockLineItemRemoveParams
	mutex    sync.RWMutex
}

// StorerMockLineItemRemoveExpectation specifies expectation struct of the storer.LineItemRemove
type StorerMockLineItemRemoveExpectation struct {
	mock    *StorerMock
	params  *StorerMockLineItemRemoveParams
	results *StorerMockLineItemRemoveResults
	Counter uint64
}

// StorerMockLineItemRemoveParams contains parameters of the storer.LineItemRemove
type StorerMockLineItemRemoveParams struct {
	ctx    context.Context
	cartID int64
	itemID int64
}

// StorerMockLineItemRemoveResults contains results of the storer.LineItemRemove
type StorerMockLineItemRemoveResults struct {
	err error
}

// Expect sets up expected params for storer.LineItemRemove
func (mmLineItemRemove *mStorerMockLineItemRemove) Expect(ctx context.Context, cartID int64, itemID int64) *mStorerMockLineItemRemove {
	if mmLineItemRemove.mock.funcLineItemRemove != nil {
		mmLineItemRemove.mock.t.Fatalf("StorerMock.LineItemRemove mock is already set by Set")
	}

	if mmLineItemRemove.defaultExpectation == nil {
		mmLineItemRemove.defaultExpectation = &StorerMockLineItemRemoveExpectation{}
	}

	mmLineItemRemove.defaultExpectation.params = &StorerMockLineItemRemoveParams{ctx, cartID, itemID}
	for _, e := range mmLineItemRemove.expectations {
		if minimock.Equal(e.params, mmLineItemRemove.defaultExpectation.params) {
			mmLineItemRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLineItemRemove.defaultExpectation.params)
		}
	}

	return mmLineItemRemove
}

// Inspect accepts an inspector function that has same arguments as the storer.LineItemRemove
func (mmLineItemRemove *mStorerMockLineItemRemove) Inspect(f func(ctx context.Context, cartID int64, itemID int64)) *mStorerMockLineItemRemove {
	if mmLineItemRemove.mock.inspectFuncLineItemRemove != nil {
		mmLineItemRemove.mock.t.Fatalf("Inspect function is already set for StorerMock.LineItemRemove")
	}

	mmLineItemRemove.mock.inspectFuncLineItemRemove = f

	return mmLineItemRemove
}

// Return sets up results that will be returned by storer.LineItemRemove
func (mmLineItemRemove *mStorerMockLineItemRemove) Return(err error) *StorerMock {
	if mmLineItemRemove.mock.funcLineItemRemove != nil {
		mmLineItemRemove.mock.t.Fatalf("StorerMock.LineItemRemove mock is already set by Set")
	}

	if mmLineItemRemove.defaultExpectation == nil {
		mmLineItemRemove.defaultExpectation = &StorerMockLineItemRemoveExpectation{mock: mmLineItemRemove.mock}
	}
	mmLineItemRemove.defaultExpectation.results = &StorerMockLineItemRemoveResults{err}
	return mmLineItemRemove.mock
}

//Set uses given function f to mock the storer.LineItemRemove method
func (mmLineItemRemove *mStorerMockLineItemRemove) Set(f func(ctx context.Context, cartID int64, itemID int64) (err error)) *StorerMock {
	if mmLineItemRemove.defaultExpectation != nil {
		mmLineItemRemove.mock.t.Fatalf("Default expectation is already set for the storer.LineItemRemove method")
	}

	if len(mmLineItemRemove.expectations) > 0 {
		mmLineItemRemove.mock.t.Fatalf("Some expectations are already set for the storer.LineItemRemove method")
	}

	mmLineItemRemove.mock.funcLineItemRemove = f
	return mmLineItemRemove.mock
}

// When sets expectation for the storer.LineItemRemove which will trigger the result defined by the following
// Then helper
func (mmLineItemRemove *mStorerMockLineItemRemove) When(ctx context.Context, cartID int64, itemID int64) *StorerMockLineItemRemoveExpectation {
	if mmLineItemRemove.mock.funcLineItemRemove != nil {
		mmLineItemRemove.mock.t.Fatalf("StorerMock.LineItemRemove mock is already set by Set")
	}

	expectation := &StorerMockLineItemRemoveExpectation{
		mock:   mmLineItemRemove.mock,
		params: &StorerMockLineItemRemoveParams{ctx, cartID, itemID},
	}
	mmLineItemRemove.expectations = append(mmLineItemRemove.expectations, expectation)
	return expectation
}

// Then sets up storer.LineItemRemove return parameters for the expectation previously defined by the When method
func (e *StorerMockLineItemRemoveExpectation) Then(err error) *StorerMock {
	e.results = &StorerMockLineItemRemoveResults{err}
	return e.mock
}

// LineItemRemove implements storer
func (mmLineItemRemove *StorerMock) LineItemRemove(ctx context.Context, cartID int64, itemID int64) (err error) {
	mm_atomic.AddUint64(&mmLineItemRemove.beforeLineItemRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmLineItemRemove.afterLineItemRemoveCounter, 1)

	if mmLineItemRemove.inspectFuncLineItemRemove != nil {
		mmLineItemRemove.inspectFuncLineItemRemove(ctx, cartID, itemID)
	}

	mm_params := &StorerMockLineItemRemoveParams{ctx, cartID, itemID}

	// Record call args
	mmLineItemRemove.LineItemRemoveMock.mutex.Lock()
	mmLineItemRemove.LineItemRemoveMock.callArgs = append(mmLineItemRemove.LineItemRemoveMock.callArgs, mm_params)
	mmLineItemRemove.LineItemRemoveMock.mutex.Unlock()

	for _, e := range mmLineItemRemove.LineItemRemoveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLineItemRemove.LineItemRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLineItemRemove.LineItemRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmLineItemRemove.LineItemRemoveMock.defaultExpectation.params
		mm_got := StorerMockLineItemRemoveParams{ctx, cartID, itemID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLineItemRemove.t.Errorf("StorerMock.LineItemRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLineItemRemove.LineItemRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmLineItemRemove.t.Fatal("No results are set for the StorerMock.LineItemRemove")
		}
		return (*mm_results).err
	}
	if mmLineItemRemove.funcLineItemRemove != nil {
		return mmLineItemRemove.funcLineItemRemove(ctx, cartID, itemID)
	}
	mmLineItemRemove.t.Fatalf("Unexpected call to StorerMock.LineItemRemove. %v %v %v", ctx, cartID, itemID)
	return
}

// LineItemRemoveAfterCounter returns a count of finished StorerMock.LineItemRemove invocations
func (mmLineItemRemove *StorerMock) LineItemRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLineItemRemove.afterLineItemRemoveCounter)
}

// LineItemRemoveBeforeCounter returns a count of StorerMock.LineItemRemove invocations
func (mmLineItemRemove *StorerMock) LineItemRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLineItemRemove.beforeLineItemRemoveCounter)
}

// Calls returns a list of arguments used in each call to StorerMock.LineItemRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLineItemRemove *mStorerMockLineItemRemove) Calls() []*StorerMockLineItemRemoveParams {
	mmLineItemRemove.mutex.RLock()

	argCopy := make([]*StorerMockLineItemRemoveParams, len(mmLineItemRemove.callArgs))
	copy(argCopy, mmLineItemRemove.callArgs)

	mmLineItemRemove.mutex.RUnlock()

	return argCopy
}

// MinimockLineItemRemoveDone returns true if the count of the LineItemRemove invocations corresponds
// the number of defined expectations
func (m *StorerMock) MinimockLineItemRemoveDone() bool {
	for _, e := range m.LineItemRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LineItemRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLineItemRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLineItemRemove != nil && mm_atomic.LoadUint64(&m.afterLineItemRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockLineItemRemoveInspect logs each unmet expectation
func (m *StorerMock) MinimockLineItemRemoveInspect() {
	for _, e := range m.LineItemRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorerMock.LineItemRemove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LineItemRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLineItemRemoveCounter) < 1 {
		if m.LineItemRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorerMock.LineItemRemove")
		} else {
			m.t.Errorf("Expected call to StorerMock.LineItemRemove with params: %#v", *m.LineItemRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLineItemRemove != nil && mm_atomic.LoadUint64(&m.afterLineItemRemoveCounter) < 1 {
		m.t.Error("Expected call to StorerMock.LineItemRemove")
	}
}

type mStorerMockLineItemsUpsert struct {
	mock               *StorerMock
	defaultExpectation *StorerMockLineItemsUpsertExpectation
	expectations       []*StorerMockLineItemsUpsertExpectation

	callArgs []*StorerMockLineItemsUpsertParams
	mutex    sync.RWMutex
}

// StorerMockLineItemsUpsertExpectation specifies expectation struct of the storer.LineItemsUpsert
type StorerMockLineItemsUpsertExpectation struct {
	mock    *StorerMock
	params  *StorerMockLineItemsUpsertParams
	results *StorerMockLineItemsUpsertResults
	Counter uint64
}

// StorerMockLineItemsUpsertParams contains parameters of the storer.LineItemsUpsert
type StorerMockLineItemsUpsertParams struct {
	ctx    context.Context
	cartID int64
	items  []*LineItem
}

// StorerMockLineItemsUpsertResults contains results of the storer.LineItemsUpsert
type StorerMockLineItemsUpsertResults struct {
	err error
}

// Expect sets up expected params for storer.LineItemsUpsert
func (mmLineItemsUpsert *mStorerMockLineItemsUpsert) Expect(ctx context.Context, cartID int64, items ...*LineItem) *mStorerMockLineItemsUpsert {
	if mmLineItemsUpsert.mock.funcLineItemsUpsert != nil {
		mmLineItemsUpsert.mock.t.Fatalf("StorerMock.LineItemsUpsert mock is already set by Set")
	}

	if mmLineItemsUpsert.defaultExpectation == nil {
		mmLineItemsUpsert.defaultExpectation = &StorerMockLineItemsUpsertExpectation{}
	}

	mmLineItemsUpsert.defaultExpectation.params = &StorerMockLineItemsUpsertParams{ctx, cartID, items}
	for _, e := range mmLineItemsUpsert.expectations {
		if minimock.Equal(e.params, mmLineItemsUpsert.defaultExpectation.params) {
			mmLineItemsUpsert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLineItemsUpsert.defaultExpectation.params)
		}
	}

	return mmLineItemsUpsert
}

// Inspect accepts an inspector function that has same arguments as the storer.LineItemsUpsert
func (mmLineItemsUpsert *mStorerMockLineItemsUpsert) Inspect(f func(ctx context.Context, cartID int64, items ...*LineItem)) *mStorerMockLineItemsUpsert {
	if mmLineItemsUpsert.mock.inspectFuncLineItemsUpsert != nil {
		mmLineItemsUpsert.mock.t.Fatalf("Inspect function is already set for StorerMock.LineItemsUpsert")
	}

	mmLineItemsUpsert.mock.inspectFuncLineItemsUpsert = f

	return mmLineItemsUpsert
}

// Return sets up results that will be returned by storer.LineItemsUpsert
func (mmLineItemsUpsert *mStorerMockLineItemsUpsert) Return(err error) *StorerMock {
	if mmLineItemsUpsert.mock.funcLineItemsUpsert != nil {
		mmLineItemsUpsert.mock.t.Fatalf("StorerMock.LineItemsUpsert mock is already set by Set")
	}

	if mmLineItemsUpsert.defaultExpectation == nil {
		mmLineItemsUpsert.defaultExpectation = &StorerMockLineItemsUpsertExpectation{mock: mmLineItemsUpsert.mock}
	}
	mmLineItemsUpsert.defaultExpectation.results = &StorerMockLineItemsUpsertResults{err}
	return mmLineItemsUpsert.mock
}

//Set uses given function f to mock the storer.LineItemsUpsert method
func (mmLineItemsUpsert *mStorerMockLineItemsUpsert) Set(f func(ctx context.Context, cartID int64, items ...*LineItem) (err error)) *StorerMock {
	if mmLineItemsUpsert.defaultExpectation != nil {
		mmLineItemsUpsert.mock.t.Fatalf("Default expectation is already set for the storer.LineItemsUpsert method")
	}

	if len(mmLineItemsUpsert.expectations) > 0 {
		mmLineItemsUpsert.mock.t.Fatalf("Some expectations are already set for the storer.LineItemsUpsert method")
	}

	mmLineItemsUpsert.mock.funcLineItemsUpsert = f
	return mmLineItemsUpsert.mock
}

// When sets expectation for the storer.LineItemsUpsert which will trigger the result defined by the following
// Then helper
func (mmLineItemsUpsert *mStorerMockLineItemsUpsert) When(ctx context.Context, cartID int64, items ...*LineItem) *StorerMockLineItemsUpsertExpectation {
	if mmLineItemsUpsert.mock.funcLineItemsUpsert != nil {
		mmLineItemsUpsert.mock.t.Fatalf("StorerMock.LineItemsUpsert mock is already set by Set")
	}

	expectation := &StorerMockLineItemsUpsertExpectation{
		mock:   mmLineItemsUpsert.mock,
		params: &StorerMockLineItemsUpsertParams{ctx, cartID, items},
	}
	mmLineItemsUpsert.expectations = append(mmLineItemsUpsert.expectations, expectation)
	return expectation
}

// Then sets up storer.LineItemsUpsert return parameters for the expectation previously defined by the When method
func (e *StorerMockLineItemsUpsertExpectation) Then(err error) *StorerMock {
	e.results = &StorerMockLineItemsUpsertResults{err}
	return e.mock
}

// LineItemsUpsert implements storer
func (mmLineItemsUpsert *StorerMock) LineItemsUpsert(ctx context.Context, cartID int64, items ...*LineItem) (err error) {
	mm_atomic.AddUint64(&mmLineItemsUpsert.beforeLineItemsUpsertCounter, 1)
	defer mm_atomic.AddUint64(&mmLineItemsUpsert.afterLineItemsUpsertCounter, 1)

	if mmLineItemsUpsert.inspectFuncLineItemsUpsert != nil {
		mmLineItemsUpsert.inspectFuncLineItemsUpsert(ctx, cartID, items...)
	}

	mm_params := &StorerMockLineItemsUpsertParams{ctx, cartID, items}

	// Record call args
	mmLineItemsUpsert.LineItemsUpsertMock.mutex.Lock()
	mmLineItemsUpsert.LineItemsUpsertMock.callArgs = append(mmLineItemsUpsert.LineItemsUpsertMock.callArgs, mm_params)
	mmLineItemsUpsert.LineItemsUpsertMock.mutex.Unlock()

	for _, e := range mmLineItemsUpsert.LineItemsUpsertMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLineItemsUpsert.LineItemsUpsertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLineItemsUpsert.LineItemsUpsertMock.defaultExpectation.Counter, 1)
		mm_want := mmLineItemsUpsert.LineItemsUpsertMock.defaultExpectation.params
		mm_got := StorerMockLineItemsUpsertParams{ctx, cartID, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLineItemsUpsert.t.Errorf("StorerMock.LineItemsUpsert got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLineItemsUpsert.LineItemsUpsertMock.defaultExpectation.results
		if mm_results == nil {
			mmLineItemsUpsert.t.Fatal("No results are set for the StorerMock.LineItemsUpsert")
		}
		return (*mm_results).err
	}
	if mmLineItemsUpsert.funcLineItemsUpsert != nil {
		return mmLineItemsUpsert.funcLineItemsUpsert(ctx, cartID, items...)
	}
	mmLineItemsUpsert.t.Fatalf("Unexpected call to StorerMock.LineItemsUpsert. %v %v %v", ctx, cartID, items)
	return
}

// LineItemsUpsertAfterCounter returns a count of finished StorerMock.LineItemsUpsert invocations
func (mmLineItemsUpsert *StorerMock) LineItemsUpsertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLineItemsUpsert.afterLineItemsUpsertCounter)
}

// LineItemsUpsertBeforeCounter returns a count of StorerMock.LineItemsUpsert invocations
func (mmLineItemsUpsert *StorerMock) LineItemsUpsertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLineItemsUpsert.beforeLineItemsUpsertCounter)
}

// Calls returns a list of arguments used in each call to StorerMock.LineItemsUpsert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLineItemsUpsert *mStorerMockLineItemsUpsert) Calls() []*StorerMockLineItemsUpsertParams {
	mmLineItemsUpsert.mutex.RLock()

	argCopy := make([]*StorerMockLineItemsUpsertParams, len(mmLineItemsUpsert.callArgs))
	copy(argCopy, mmLineItemsUpsert.callArgs)

	mmLineItemsUpsert.mutex.RUnlock()

	return argCopy
}

// MinimockLineItemsUpsertDone returns true if the count of the LineItemsUpsert invocations corresponds
// the number of defined expectations
func (m *StorerMock) MinimockLineItemsUpsertDone() bool {
	for _, e := range m.LineItemsUpsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LineItemsUpsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLineItemsUpsertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLineItemsUpsert != nil && mm_atomic.LoadUint64(&m.afterLineItemsUpsertCounter) < 1 {
		return false
	}
	return true
}

// MinimockLineItemsUpsertInspect logs each unmet expectation
func (m *StorerMock) MinimockLineItemsUpsertInspect() {
	for _, e := range m.LineItemsUpsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorerMock.LineItemsUpsert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LineItemsUpsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLineItemsUpsertCounter) < 1 {
		if m.LineItemsUpsertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorerMock.LineItemsUpsert")
		} else {
			m.t.Errorf("Expected call to StorerMock.LineItemsUpsert with params: %#v", *m.LineItemsUpsertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLineItemsUpsert != nil && mm_atomic.LoadUint64(&m.afterLineItemsUpsertCounter) < 1 {
		m.t.Error("Expected call to StorerMock.LineItemsUpsert")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginTxInspect()

		m.MinimockCartCreateInspect()

		m.MinimockCartEmptyInspect()

		m.MinimockCartWithItemsByCartIDInspect()

		m.MinimockCommitInspect()

		m.MinimockLineItemRemoveInspect()

		m.MinimockLineItemsUpsertInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginTxDone() &&
		m.MinimockCartCreateDone() &&
		m.MinimockCartEmptyDone() &&
		m.MinimockCartWithItemsByCartIDDone() &&
		m.MinimockCommitDone() &&
		m.MinimockLineItemRemoveDone() &&
		m.MinimockLineItemsUpsertDone()
}
